[TOC]
## JS基础
#### 1、Object.assign（）
#### 2、for（）和forEach（）
###### 一、for()循环：
​	通过下标，对循环中的代码反复执行，功能强大，可以通过index取得元素。在处理比较复杂的处理的时候较为方便

###### 二、 forEach()循环
​	forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。foreach有的也叫增强for循环，foreach其实是for循环的一个特殊简化版。注意，forEach() 对于空数组是不会执行回调函数的
1. 遍历
for循环按顺序遍历，forEach使用iterator迭代器遍历
2. 数据结构
for循环是随机访问元素，foreach是顺序链表访问元素
3. 性能上
在1000000这个级别下，forEach 的性能高于for，在10000000这个级别下，forEach 的性能还是高于for
在100000000级以上的量级上 ，forEach的性能远远低于for的性能

* 对于arraylist，是顺序表，使用for循环可以顺序访问，速度较快；使用foreach会比for循环稍慢一些。
* 对于linkedlist，是单链表，使用for循环每次都要从第一个元素读取next域来读取，速度非常慢；使用foreach可以直接读取当前结点，数据较快；
4. 如何选择
 foreach相对于for循环，代码减少了，但是foreach依赖IEnumerable。在运行的时候效率低于for循环。当然了，在处理不确定循环次数的循环，或者循环次数需要计算的情况下。使用foreach比较方便。而且foreach的代码经过编译系统的代码优化后，和for循环的循环类似。


   可以说，foreach语句是for语句的特殊简化版本，在遍历数组、集合方面，foreach为开发人员提供了极大的方便。在复杂的循环设计时，还是应该使用for循环更加的灵活。
#### 3、var与let、const的区别
###### 一、var声明的变量会挂载在window上，而let和const声明的变量不会

```javascript
    var  a = 100;
    console.log(a,window.a);     // 100   100
     
    let b = 10;
    console.log(b,window.b);     // 10   undefined

    const c = 1;
    console.log(c,window.c);    //  1    undefined
```
###### 二、function里面的作用域
作用域就是可以 访问到这个变量的范围。
如果var定义在function外面，则作用域是全局的，如果定义在function里面，var的作用域是function。
而let和const定义的变量的作用域都是包裹着它的大括号里的代码块。并且，let和const定义的变量不会被hoisting
```js
    function funcVar() {
        if (true) {
            var tmp = 123;
        }
        console.log(tmp); // 123
    }
    function funcConst() {
        if (true) { // <--这里开始
            const tmp = 123;
        }// <--这里结束
        console.log(tmp); // ReferenceError: tmp is not defined
    }
```
```js
    let x = 10;
    if (x == 10) {// <--这个x是外面的x
        let x = 20; // 里面重新定义了一个x，这个x的作用域只在代码块里
        console.log(x); // 20 -- 里面的x
    }// <-- 出了这个块，里面的x就没了
    console.log(x); // 10 -- 外面的x
```
```js
    let x = 10;
    if (x == 10) {// <--外面的x
        x = 20; //还是外面的x
        console.log(x); // 20;
    }// <--这里面并没有定义x，所以改变的是外层的x，
    console.log(x); // 20
```
###### 三、var声明存在变量提升，let和const不存在变量提升
在js中，可以在变量定义之前使用变量，因为变量的定义会被提到作用域最顶上（看上去的定义的位置其实只是赋值）。这个过程叫做hoisting。
而用let和const定义的变量并不会被hoisting。
```js
    console.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值
    var a = 100;
```
```js
    console.log(b); // 报错：b is not defined  ===> 找不到b这个变量
    let b = 10;
```
```js
    console.log(c); // 报错：c is not defined  ===> 找不到c这个变量
    const c = 10;
```
###### 四、let和const声明形成块作用域
```js
    if(1){
        var a = 100;    
        let b = 10;
    }
    console.log(a); // 100
    console.log(b)  // 报错：b is not defined  ===找不到b这个变量
```
```js
    if(1){

        var a = 100;
            
        const c = 1;
    }
    console.log(a); // 100
    console.log(c)  // 报错：c is not defined  ===> 找不到c这个变量
```
###### 五、同一作用域下let和const不能声明同名变量，而var可以
```js
    var a = 100;
    console.log(a); // 100

    var a = 10;
    console.log(a); // 10
```
```js
    let a = 100;
    let a = 10;

    //  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。
```
###### 六、let 和 var 在for循环中的区别，const在for循环中
下面的代码中，var的作用域是全局的（for是个代码块并不是个函数），所以整个过程中只有一个i，所以在三次循环中，绑定的是统一个i,这样最后i变成3了之后，arr1里面三个函数都返回了3
```js
    const arr1 = [];
    for (var i=0; i < 3; i++) {
        arr1.push(() => i);
    }
    arr1.map(x => x()); // [3,3,3]
    console.log(i); // 3
```
下面代码中，let的作用域是for循环这个代码块，所以arr2中的三个函数绑定的j是不同的。 而从for循环之外是没有办法直接访问j的。
```js
    const arr2 = [];
    for (let j=0; j < 3; j++) {
        arr2.push(() => j);
    }
    arr2.map(x => x()); // [0,1,2]
    console.log(j); // ReferenceError: j is not defined
```
const在for循环中
```js
    // TypeError: Assignment to constant variable
    for (const i=0; i<3; i++) { //i++ 会引发TypeError， 因为i是const
        console.log(i);
    }
    //但是可以这样用： 
    for (const i of [0, 1, 2]) { // 每次i都重新绑定。
        const message = i + '. ' + 'test'; // 每次for循环都是一个新的作用域。
        console.log(message);
    }
```

###### 七、暂存死区
```js
    var a = 100;

    if(1){
        a = 10;
        //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
        // 而这时，还未到声明时候，所以控制台Error:a is not defined
        let a = 1;
    }
```
###### 八、const
```js
    /*
    * 　　1、一旦声明必须赋值,不能使用null占位。
    *
    * 　　2、声明后不能再修改
    *
    * 　　3、如果声明的是复合类型数据，可以修改其属性
    *
    * */

    const a = 100; 

    const list = [];
    list[0] = 10;
    console.log(list);　　// [10]

    const obj = {a:100};
    obj.name = 'apple';
    obj.a = 10000;
    console.log(obj);　　// {a:10000,name:'apple'}
```
#### 4、JS的基础数据类型有哪些
JS数据类型：基础概念 

请注意：JS的数据类型有8种。

在ES5的时候，我们认知的数据类型确实是 6种：Number、String、Boolean、undefined、object、Null。

ES6 中新增了一种 Symbol 。这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。

谷歌67版本中还出现了一种 bigInt。是指安全存储、操作大整数。（但是很多人不把这个做为一个类型）。

JS数据类型：JS 的数据类型有几种？

     8种。Number、String、Boolean、Null、undefined、object、symbol、bigInt。

JS数据类型：Object 中包含了哪几种类型？

      其中包含了Data、function、Array等。这三种是常规用的。

JS数据类型：JS的基本类型和引用类型有哪些呢？

    基本类型（单类型）：除Object。 String、Number、boolean、null、undefined。

    引用类型：object。里面包含的 function、Array、Date。

    基本类型的实例：

    引用类型的实例：

JS数据类型：JS 中 typeof 输出分别是什么？

    { } 、[ ] 输出 object。

    console.log( ) 输出 function。
<font color="red">注意一点：NaN 是 Number 中的一种，非Number 。</font>

|          |          |                      |
|:--------:|:--------:|:--------------------:|
|  string  |  string  |        字符串        |
|  Number  |  Number  |       数字类型       |
| Boolean  | Boolean  |        布尔型        |
| Undefind | Undefind | 没有初始化、定义的值 |
|   Null   |  Object  |     不存在的对象     |
|   NaN    |  Number  |  Number中的特殊数值  |
|  Object  | Function |                      |

<font color="skyblue">JS数据类型：如何判断数据类型？</font>
1､typeof 操作符（通用：上面有内容有讲到）

2､toString ( )    

* 作用：其他类型转成 string 的方法

* 支持：number、boolean、string、object 

* 不支持：null 、undefined
```js
    let a = true;
    a.toString()
    "true"
    let b = 45;
    b.toString()
    "45"
```

3､toLocaleString ( )

* 把数组转成本地字符串
```js
    let arr = ["1","2","3","4","5"];
    arr.toLocaleString()
    "1,2,3,4,5"
```
4､检测数组类型的方法 
* instanceof 操作符
```js
    let arr = ['1','2','3'];
    console.log(arr instanceof Array)
    true

    let test = "1"
    console.log(test instanceof Array)
    false
```
* 对象的constructor属性
```js
    let arr = ['1','2']
    console.log(arr.constructor === Array)
    true

    let arr1 = 123
    console.log(arr1.constructor === Array)
    false
```
* Array.isArray()检验值是否为数组
```js
    let demo = ['1','2'];
    console.log(Array.isArray(demo))
    true

    let demo1 = 123
    console.log(Array.isArray(demo1))
    false
```

<font color="skyblue">JS数据类型：null 和 undefined 有什么区别？</font>
Null 只有一个值，是 null。不存在的对象。

Undefined 只有一个值，是undefined。没有初始化。undefined 是从 null 中派生出来的。

简单理解就是：undefined 是没有定义的，null 是定义了但是为空。

<font color="skyblue">JS数据类型：null 不存在的原因是什么？如何解决？</font>
  不存在的原因是：

                1､方法不存在

                2､对象不存在

                3､字符串变量不存在

                4､接口类型对象没初始化 

    解决方法：

                做判断处理的时候，放在设定值的最前面


<font color="skyblue">JS数据类型：== 和 === 有什么区别，什么场景下使用？</font>

  == 表示相同。

            比较的是物理地址，相当于比较两个对象的 hashCode ，肯定不相等的。

            类型不同，值也可能相等。

    === 表示严格相同。

            例：同为 null／undefined ，相等。

    简单理解就是 == 就是先比较数据类型是否一样。=== 类型不同直接就是 false。

<font color="skyblue">JS数据类型：对象可以比较地？</font>

对象是可以比较，遍历比较key 和 value就行， Object.is(value1, value2)。

<font color="skyblue">JS数据类型：总结</font>
 1､Undefined 类型

只有一个值。在使用var 声明变量但未对其加初始化时，这个变量就是undefined。
```js
    var message;
    console.log( message == undefined)
    true
```
2､Null 类型

只有一个值。null是表示一个空对象指针，这也是typeof操作符检测 null 值时会返回 object 的原因。

3､Boolean 类型

使用最多的一个类型，有两个字面值，分别是true、false。true不一定等于1,false不一定等于0。

boolean类型的字面值是区分大小写的。True和False是标识符
```js
    var messahe = "hi"
    if (message) {
        console.log("测试成功")
    }
    测试成功
```
 4､Number 类型
      数字类型，表示数据的整数和浮点数。某些语言中也称为“双精度值”。
      var intNum = 55;十进制
      var num = 012;八进制
      var octalNum = 0x23;十六进制

5､String 类型

字符串可以有单引号、双引号表示。字符串是不可变的，一旦创建，值就不能改变
要改变某个变量保存的字符串，首先要销毁原来的字符串，然后于用另一个包含的字符串填充该变量。

```js
    var lang = 'java'
    var lang = lang + 'script'
    console.log(lang);
    javascript
```
注）toString()可以输出二进制、八进制、十进制，十六进制。

null和undefined没有toString()方法，用String函数不返回这两个值的字面量。

    6､Object 类型

        ECMAjavascript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。创建object类型的实例并为其添加属性（或）方法，就可以自定义创建对象。

        如：var o = new Object( );

        object 的每个实例都有下列属性和方法：

        constructor：保存着用于创建当前对象的函数。(构造函数)constructor就是object();

        hasOwnProperty(propertyName):用于检查给定的当前属性在当前对象实例中）而不是在实例原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字稚串形式指定(例如：o.hasOwnProperty(“name”))。

        isPrototypeOf(object):用于检查传入的对象是否是传入对象原型。

        propertyIsEnumerable(propertyName):用于检查给定属性是否能够用for-in语句。与hasOwnProperty（）方法一样，作为参数的属性名必须以字符串形式指定。

        toLocaleString( ):返回对象的字符串表示，该字符串与执行环境的地区对应。

        toString( ):返回对象的字符串表示。

        valueOf( ):返回对象的字符串、数值或者布尔值表示。通常与toString( )方法的返回值得相同

<font color="red">ECMAJS中object是所有对象的基础，因些所有对象都具有这些基本的属性和方法。</font>

  7､ Symbol 类型

Symbol 类型的对象永远不相等，即便创建的时候传入相同的值。因此，可以用解决属性名冲突的问题（适用于多少编码），做为标记。

这是 es6 新增的数据类型
```js
    typeof Symbol() ==="symbol"
    true
    Symbol("key") !== Symbol("key")
    true
    Symbol("key") === Symbol("key")
    false
    Symbol("key") == Symbol("key")
    false
```
  8､BigInt 类型

Javascript 中的任意精度整数，可以安全存储和操作大整数。即始超出 Number 能够表示的安全整数范围。是 chrome 67中的新功能。

#### 5. 什么是Symbol，它的使用场景是什么
###### ES6中引入的一种新的基础数据类型（primitive type）
Symbol是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。

通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例：
```js
    let s1 = Symbol()
```
或者，你也可以在调用Symbol()函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：
```js
    let s2 = Symbol('another symbol')
```
如果用当下比较流行的TypeScript的方式来描述这个Symbol()函数的话，可以表示成：
```js
    /**
     * @param  {any} description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等
     */
    function Symbol(description?: any): symbol
```
由于Symbol是一种基础数据类型，所以当我们使用typeof去检查它的类型的时候，它会返回一个属于自己的类型symbol，而不是什么string、object之类的：
```js
    typeof s1  // 'symbol'
```
另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回false：
```js
    let s1 = Symbol()
    let s2 = Symbol('another symbol')
    let s3 = Symbol('another symbol')

    s1 === s2 // false
    s2 === s3 // false
```
###### 应用场景1：使用Symbol来作为对象属性名(key)
在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：
```js
    let obj = {
        abc: 123,
        "hello": "world"
    }

    obj["abc"] // 123
    obj["hello"] // 'world'
    而现在，Symbol可同样用于对象属性的定义和访问：

    const PROP_NAME = Symbol()
    const PROP_AGE = Symbol()

    let obj = {
        [PROP_NAME]: "一斤代码"
    }
    obj[PROP_AGE] = 18

    obj[PROP_NAME] // '一斤代码'
    obj[PROP_AGE] // 18
```
随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用Object.keys()或者for...in来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：
```js
    let obj = {
        [Symbol('name')]: '一斤代码',
        age: 18,
        title: 'Engineer'
    }

    Object.keys(obj)   // ['age', 'title']

    for (let p in obj) {
        console.log(p)   // 分别会输出：'age' 和 'title'
    }

    Object.getOwnPropertyNames(obj)   // ['age', 'title']
```
由上代码可知，Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。

也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：
```js
    JSON.stringify(obj)  // {"age":18,"title":"Engineer"}
```
我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。

然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：
```js
    // 使用Object的API
    Object.getOwnPropertySymbols(obj) // [Symbol(name)]

    // 使用新增的反射API
    Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']   
```
###### 应用场景2：使用Symbol来替代常量
先来看一下下面的代码，是不是在你的代码里经常会出现？
```js
    const TYPE_AUDIO = 'AUDIO'
    const TYPE_VIDEO = 'VIDEO'
    const TYPE_IMAGE = 'IMAGE'

    function handleFileResource(resource) {
        switch(resource.type) {
            case TYPE_AUDIO:
            playAudio(resource)
            break
            case TYPE_VIDEO:
            playVideo(resource)
            break
            case TYPE_IMAGE:
            previewImage(resource)
            break
            default:
            throw new Error('Unknown type of resource')
        }
    }
```
如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的'AUDIO'、'VIDEO'、 'IMAGE'），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。

现在有了Symbol，我们大可不必这么麻烦了：
```js
    const TYPE_AUDIO = Symbol()
    const TYPE_VIDEO = Symbol()
    const TYPE_IMAGE = Symbol()
```
这样定义，直接就保证了三个常量的值是唯一的了！
###### 应用场景3：使用Symbol定义类的私有属性/方法
我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。

而有了Symbol以及模块化机制，类的私有属性和方法才变成可能。例如：

在文件 a.js中
```js
    const PASSWORD = Symbol()

    class Login {
        constructor(username, password) {
            this.username = username
            this[PASSWORD] = password
        }

        checkPassword(pwd) {
            return this[PASSWORD] === pwd
        }
    }

    export default Login
```
在文件 b.js 中
```js
    import Login from './a'

    const login = new Login('admin', '123456')

    login.checkPassword('123456')  // true

    login.PASSWORD  // oh!no!
    login[PASSWORD] // oh!no!
    login["PASSWORD"] // oh!no!   
```
由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。

注册和获取全局Symbol

通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了iframe），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例：

```js
    let gs1 = Symbol.for('global_symbol_1')  //注册一个全局Symbol
    let gs2 = Symbol.for('global_symbol_1')  //获取全局Symbol

    gs1 === gs2  // true
```
这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。


###### Symbol的使用场景
*独一无二*
```js
    // 没有参数的情况
    var s1 = Symbol();
    var s2 = Symbol();
    s1 === s2 // false
    // 有参数的情况
    var s1 = Symbol("foo");
    var s2 = Symbol("foo");
    s1 === s2 // false
```
这里的'foo'是该Symbol的一个描述，但是并非两个参数都为'foo' ，就能够使得这两个Symbol相同。

* 作为属性名的使用
```js
    var mySymbol = Symbol();
    // 第一种写法
    var a = {};
    a[mySymbol] = 'Hello!';
    // 第二种写法
    var a = { [mySymbol]: 'Hello!'};
    // 第三种写法
    var a = {};
    Object.defineProperty(a, mySymbol, { value: 'Hello!' });
    // 以上写法都得到同样结果
    a[mySymbol] // "Hello!"
```
注意，这里不可以使用 \<code>a.mySymbol = 'hello';\</code>来填充该属性值。因为点运算符后面总是字符串.
* 为什么要使用Symbol?
有这样一种场景，我们想区分两个属性，其实我们并不在意，这两个属性值究竟是什么，我们在意的是，这两个属性绝对要区分开来！例如:
```js
    var shapeType = { triangle: 'Triangle'};
    function getArea(shape, options) { 
        var area = 0; 
        switch (shape) { 
            case shapeType.triangle:
            area = .5 * options.width * options.height; 
            break; 
        } 
        return area;
    }

    getArea(shapeType.triangle, { width: 100, height: 100 });
```
这个时候，我们仅仅是想区分各种形状，因为不同的形状用不同的计算面积的公式。这里使用的是triangle的名字叫做‘Triangle’，而是事实上我们不想对triangle去特地取个名，我们只想要区分triangle这个形状不同于任何其他形状，那么这个时候Symbol就派上用场啦
```js
    const shapeType = {
        triangle: Symbol()
    };
```
我们不用非要去给变量赋一个字符串的值，去区分它和别的变量的值不同，因为去给每个变量取个语义化而又不同的值是一件伤脑子的事，当我们只需要知道每个变量的值都是百分百不同的即可，这时候我们就可以用Symbol。


#### 6.数组原型上面的方法有哪些，哪些是可以改变数组的，哪些是不可以的

###### 一、数组的原型方法汇总
* join(separator)
    -

将数组的元素组起一个字符串，以 `separator` 为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符
```js
    var arr = [1, 2, 3];
    console.log(arr.join()); // 1,2,3
    console.log(arr.join("-")); // 1-2-3
    console.log(arr); // [1, 2, 3]（原数组不变）
```
通过join()方法可以实现重复字符串，只需传入字符串已经重复的次数，就能返回重复后的字符串，函数如下：
```js
    function repeatString(str, n) {
        return new Array(n + 1).join(str);
    }
    console.log(repeatString("abc", 3)); // abcabcabc
    console.log(repeatString("Hi", 5)); // HiHiHiHiHi 
```
* push()和pop()
    -
    
    - `push()`：可以接收任意数量的参数，把他们逐个添加到数组末尾，斌返回修改后数组的长度。
    - `pop()`：数组末尾移除最后一项，减少数组的length值，然后返回移除的项。
    ```js
        var arr = ["Lily","lucy","Tom","lazy"];
        var count = arr.push("Jack","Sean");
        console.log(count); // 6
        console.log(arr); // ["Lily", "lucy", "Tom", "lazy", "Jack", "Sean"]
        var item = arr.pop();
        console.log(item); // Sean
        console.log(arr); // ["Lily", "lucy", "Tom", "lazy", "Jack"]
    ```

* shift() 和 unshift()
    -
    
    - shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined
    - unshift()：将参数添加到原数组开头，并返回数组的长度。
    - 这组方法和上面的`push()和pop()`方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。
    ```js
        var arr = ["Lily", "lucy", "Tom", "lazy"];
        var count = arr.unshift("Jack", "Sean");
        console.log(count); // 6
        console.log(arr); //["Jack", "Sean", "Lily",  "lucy", "Tom", "lazy"]
        var item = arr.shift();
        console.log(item); // Jack
        console.log(arr); // ["Sean", "Lily", "lucy", "Tom", "lazy"]
    ```
* sort()
    -
    
    - 按升序排列数组项————即最小的值位于最前面，最大的值排在最后面。
    - 在排序时，`sort()` 方法会调用每个数组项的 `toString()` 转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， `sort()` 方法比较的也是字符串，因此会出现以下的这种情况：
    ```js
        var arr1 = ["a", "d", "c", "b"];
        console.log(arr1.sort()); // ["a", "b", "c", "d"]
        arr2 = [13, 24, 51, 3];
        console.log(arr2.sort()); // [13, 24, 3, 51] 两位数字先比较第一位再比较第二位
        console.log(arr2); // [13, 24, 3, 51](元数组被改变)
    ```
    为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们制定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：
    ```js
        function compare(value1, value2) {
            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        }
        arr2 = [13, 24, 51, 3];
        console.log(arr2.sort(compare)); // [3, 13, 24, 51]
    ```
    如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：
    ```js
        function compare(value1, value2) {
            if (value1 < value2) {
                return 1;
            } else if (value1 > value2) {
                return -1;
            } else {
                return 0;
            }
        }
        arr2 = [13, 24, 51, 3];
        console.log(arr2.sort(compare)); // [51, 24, 13, 3]
    ```
* resverse()
    -

    - 反转数组项的顺序
    ```js
        var arr = [13, 24, 51, 3];
        console.log(arr.reverse()); //[3, 51, 24, 13]
        console.log(arr); //[3, 51, 24, 13](原数组改变)
    ```
* concat()
    -

    - 将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 `concat()` 方法传递参数的情况下，它只是复制当前数组并返回副本。
    ```js
        var arr = [1,3,5,7];
        var arrCopy = arr.concat(9,[11,13]);
        console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
        console.log(arr); // [1, 3, 5, 7](原数组未被修改)
    ```
    - 从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？
    ```js
        var arrCopy2 = arr.concat([9,[11,13]]);
        console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
        console.log(arrCopy2[5]); //[11, 13]
    ```
    - 上述代码中， `arrCopy2` 数组的第五项是一个包含两项的数组，也就是说`concat`方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当做一项添加到 `arrCopy2` 中。
* slice()
    -

    - 返回从原数组中指定下标到结束下标之间的项组成新的数组。 `slice()` 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， `slice()` 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项————但不包括结束位置的项。

    ```js
        var arr = [1,3,5,7,9,11];
        var arrCopy = arr.slice(1);
        var arrCopy2 = arr.slice(1,4);
        var arrCopy3 = arr.slice(1,-2);
        var arrCopy4 = arr.slice(-4,-1);
        console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
        console.log(arrCopy); //[3, 5, 7, 9, 11]
        console.log(arrCopy2); //[3, 5, 7]
        console.log(arrCopy3); //[3, 5, 7]
        console.log(arrCopy4); //[5, 7, 9]
        arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。 
        arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。 
        arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 
        arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。
    ```
* splice()
    -
    - splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。
    - 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。
    -   + 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。
        + 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6
    - splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。
    ```js
        var arr = [1,3,5,7,9,11];
        var arrRemoved = arr.splice(0,2);
        console.log(arr); //[5, 7, 9, 11]
        console.log(arrRemoved); //[1, 3]
        var arrRemoved2 = arr.splice(2,0,4,6);
        console.log(arr); // [5, 7, 4, 6, 9, 11]
        console.log(arrRemoved2); // []
        var arrRemoved3 = arr.splice(1,1,2,4);
        console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
        console.log(arrRemoved3); //[7]
    ```
* indexOf()和 lastIndexOf()
    -
    -   + indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找
        + lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。
    - 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。
    ```js
        var arr = [1,3,5,7,7,5,3,1];
        console.log(arr.indexOf(5)); //2
        console.log(arr.lastIndexOf(5)); //5
        console.log(arr.indexOf(5,2)); //2
        console.log(arr.lastIndexOf(5,4)); //2
        console.log(arr.indexOf("5")); //-1
    ```
* forEach()
    -
    - 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。
    ```js
        var arr = [1, 2, 3, 4, 5];
        arr.forEach(function(x, index, a){
        console.log(x + '|' + index + '|' + (a === arr));
        });
        // 输出为：
        // 1|0|true
        // 2|1|true
        // 3|2|true
        // 4|3|true
        // 5|4|true 
    ```
* map()
    - 
    - 指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
    - 下面代码利用map方法实现数组中每个数求平方。
    ```js
        var arr = [1, 2, 3, 4, 5];
        var arr2 = arr.map(function(item){
            return item*item;
        });
        console.log(arr2); //[1, 4, 9, 16, 25]
    ```
* filter()
    -
    - “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
    ```js
        var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        var arr2 = arr.filter(function(x, index) {
        return index % 3 === 0 || x >= 8;
        }); 
        console.log(arr2); //[1, 4, 7, 8, 9, 10]
    ```
* every()
    -
    - 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回` true `。
    ```js
        var arr = [1, 2, 3, 4, 5];
        var arr2 = arr.every(function(x) {
        return x < 10;
        }); 
        console.log(arr2); //true
        var arr3 = arr.every(function(x) {
        return x < 3;
        }); 
        console.log(arr3); // false
    ```
* some()
    -
    - 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。
    ```js 
        var arr = [1, 2, 3, 4, 5];
        var arr2 = arr.some(function(x) {
        return x < 3;
        }); 
        console.log(arr2); //true
        var arr3 = arr.some(function(x) {
        return x < 1;
        }); 
        console.log(arr3); // false
    ```
* reduce()和 reduceRight()
    -
    - 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。`reduce()` 方法从数组的第一项开始，逐个遍历到最后。而` reduceRight()` 则从数组的最后一项开始，向前遍历到第一项。
    - 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
    - 传给 `reduce()` 和 `reduceRight()` 的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
    - 下面代码用 `reduce()` 实现数组求和，数组一开始加了一个初始值10。
    ```js
        var values = [1,2,3,4,5];
        var sum = values.reduceRight(function(prev, cur, index, array){
            return prev + cur;
        },10);
        console.log(sum); //25
    ```

###### 二、改变原数组的方法（9个）
>ES5:
splice() / sort() / pop() / shift() / push() / unshift() / reverse()

>ES6:
copyWithin() / fill()

+ splice() 添加/删除数组元素
定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目
语法： array.splice(index,howmany,item1,…,itemX)
参数:
index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
item1, …, itemX： 可选。向数组添加的新项目。
返回值: 如果有元素被删除,返回包含被删除项目的新数组。
eg1:删除元素
```js
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3]
console.log(a); // [4,5,6,7]
// 从数组下标0开始，删除3个元素
let item = a.splice(-1, 3); // [7]
// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7
```
eg2: 删除并添加
```js
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,3,‘添加’); // [1,2,3]
console.log(a); // [‘添加’,4,5,6,7]
// 从数组下标0开始，删除3个元素，并添加元素’添加’
let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-2,3,‘添加1’,‘添加2’); // [6,7]
console.log(b); // [1,2,3,4,5,‘添加1’,‘添加2’]
// 从数组最后第二个元素开始，删除3个元素，并添加两个元素’添加1’、‘添加2’
```
eg3: 不删除只添加:
```js
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,0,‘添加1’,‘添加2’); // [] 没有删除元素，返回空数组
console.log(a); // [‘添加1’,‘添加2’,1,2,3,4,5,6,7]
let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-1,0,‘添加1’,‘添加2’); // [] 没有删除元素，返回空数组
console.log(b); // [1,2,3,4,5,6,‘添加1’,‘添加2’,7] 在最后一个元素的前面添加两个元素
```
从上述三个栗子可以得出:
数组如果元素不够，会删除到最后一个元素为止
操作的元素，包括开始的那个元素
可以添加很多个元素
添加是在开始的元素前面添加的

+ sort() 数组排序
定义: sort()方法对数组元素进行排序，并返回这个数组。
参数可选: 规定排序顺序的比较函数。
默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。
```js
// 字符串排列 看起来很正常
let a = [“Banana”, “Orange”, “Apple”, “Mango”];
a.sort(); // [“Apple”,“Banana”,“Mango”,“Orange”]
// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的
let	a = [10, 1, 3, 20,25,8];
console.log(a.sort()) // [1,10,20,25,3,8];
```
比较函数的两个参数：

sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：

若比较函数返回值<0，那么a将排到b的前面;
若比较函数返回值=0，那么a 和 b 相对位置不变；
若比较函数返回值>0，那么b 排在a 将的前面；
对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章深入了解javascript的sort方法

sort排序常见用法：

数组元素为数字的升序、降序:
```js
let array = [10, 1, 3, 4,20,4,25,8];
// 升序 a-b < 0 a将排到b的前面，按照a的大小来排序的
// 比如被减数a是10，减数是20 10-20 < 0 被减数a(10)在减数b(20)前面
array.sort(function(a,b){
return a-b;
});
console.log(array); // [1,3,4,4,8,10,20,25];
// 降序 被减数和减数调换了 20-10>0 被减数b(20)在减数a(10)的前面
array.sort(function(a,b){
return b-a;
});
console.log(array); // [25,20,10,8,4,4,3,1];
数组多条件排序
let array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}];
array.sort(function(a,b){
if(a.id === b.id){// 如果id的值相等，按照age的值降序
return b.age - a.age
}else{ // 如果id的值不相等，按照id的值升序
return a.id - b.id
}
})
// [{“id”:2,“age”:8},{“id”:5,“age”:4},{“id”:6,“age”:10},{“id”:9,“age”:6},{“id”:10,“age”:9},{“id”:10,“age”:2}]
自定义比较函数，天空才是你的极限
类似的：运用好返回值，我们可以写出任意符合自己需求的比较函数

let array = [{name:‘Koro1’},{name:‘Koro1’},{name:‘OB’},{name:‘Koro1’},{name:‘OB’},{name:‘OB’}];
array.sort(function(a,b){
if(a.name === ‘Koro1’){// 如果name是’Koro1’ 返回-1 ，-1<0 a排在b的前面
return -1
}else{ // 如果不是的话，a排在b的后面
return 1
}
})
// [{“name”:“Koro1”},{“name”:“Koro1”},{“name”:“Koro1”},{“name”:“OB”},{“name”:“OB”},{“name”:“OB”}]
```
+ pop() 删除一个数组中的最后的一个元素
定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。
参数: 无。
```js
let a = [1,2,3];
let item = a.pop(); // 3
console.log(a); // [1,2]
```
+ shift() 删除数组的第一个元素
定义: shift()方法删除数组的第一个元素，并返回这个元素。
参数: 无。
```js
let a = [1,2,3];
let item = a.shift(); // 1
console.log(a); // [2,3]
```
+ push() 向数组的末尾添加元素
定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
参数: item1, item2, …, itemX ,要添加到数组末尾的元素
```js
let a = [1,2,3];
let item = a.push(‘末尾’); // 4
console.log(a); // [1,2,3,‘末尾’]
```
+ unshift()
定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
参数: item1, item2, …, itemX ,要添加到数组开头的元素
```js
let a = [1,2,3];
let item = a.unshift(‘开头’); // 4
console.log(a); // [‘开头’,1,2,3]
```

+ reverse() 颠倒数组中元素的顺序
定义: reverse() 方法用于颠倒数组中元素的顺序。
参数: 无
```js
let a = [1,2,3];
a.reverse();
console.log(a); // [3,2,1]
```

+ ES6: copyWithin() 指定位置的成员复制到其他位置
定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。
语法:array.copyWithin(target, start = 0, end = this.length)
参数:三个参数都是数值，如果不是，会自动转为数值.

    - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
    - end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。
    - 浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持

eg:
```js
// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]
let a=[‘OB1’,‘Koro1’,‘OB2’,‘Koro2’,‘OB3’,‘Koro3’,‘OB4’,‘Koro4’,‘OB5’,‘Koro5’]
// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换
a.copyWithin(2,3,5)
// [“OB1”,“Koro1”,“Koro2”,“OB3”,“OB3”,“Koro3”,“OB4”,“Koro4”,“OB5”,“Koro5”]
```
从上述栗子:

第一个参数是开始被替换的元素位置
要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取
数组的长度不会改变
读了几个元素就从开始被替换的地方替换几个元素

+ ES6: fill() 填充数组
定义: 使用给定值，填充一个数组。
参数:
    - 第一个元素(必须): 要填充数组的值
    - 第二个元素(可选): 填充的开始位置,默认值为0
    - 第三个元素(可选)：填充的结束位置，默认是为this.length
    - MDN浏览器兼容
```js
[‘a’, ‘b’, ‘c’].fill(7)
// [7, 7, 7]
[‘a’, ‘b’, ‘c’].fill(7, 1, 2)
// [‘a’, 7, ‘c’]
```

###### 三、不改变原数组的方法（8个）
>ES5:
slice() / join() / toLocateString() / toString() / cancat() / indexOf() / lastIndexOf()

>ES7:
includes() 查找数组是否包含某个元素 返回布尔

###### 四、遍历方法（12个）:
js中遍历数组并不会改变原始数组的方法总共有12个:
>ES5:
forEach() / every() / some() / filter() / map() / reduce() / reduceRight() 

>ES6:
find() / findIndex() / keys() / values() / entries() 


###### 五、数组操作
- 1.数组扁平化
    数组扁平化是指将一个多维数组变为一个一维数组
    ```js
    const arr = [1, [2, [3, [4, 5]]], 6];
    // => [1, 2, 3, 4, 5, 6]
    ```
    + 方法一：使用flat()
        ```js
        const res1 = arr.flat(Infinity);
        ```
    + 方法二：利用正则
        ```js
        const res2 = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
        ```
        但数据类型都会变为字符串

    + 方法三：正则改良版本
        ```js
        const res3 = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']');
        ```
    + 方法四：使用reduce
        ```js
        const flatten = arr => {
            return arr.reduce((pre, cur) => {
                return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
            }, [])
        }
        const res4 = flatten(arr);
        ```
    + 方法五：函数递归
        ```js
        const res5 = [];
        const fn = arr => {
            for (let i = 0; i < arr.length; i++) {
                if (Array.isArray(arr[i])) {
                fn(arr[i]);
                } else {
                res5.push(arr[i]);
                }
            }
        }
        fn(arr);
        ```
- 2.数组去重
    ```js
    const arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
    // => [1, '1', 17, true, false, 'true', 'a', {}, {}]
    ```
    + 方法一：利用Set
    
        ```js
        const res1 = Array.from(new Set(arr));
        ```
        > 

        ---
        第二种

        ```js
        const arr = [1, 1, 2, 2, 3, 4, 5, 5]
        const newArr = [...new Set(arr)]
        ```
        ==<font color="red">new Set(arr)</font>== 接受一个数组参数并生成一个set结构的数据类型。set数据类型的元素不会重复且是 ==<font color="red">Array Iterator</font>== ，所以可以利用这个特性来去重。
        <br/>

    + 方法二：两层for循环+splice
        ```js
        const unique1 = arr => {
            let len = arr.length;
            for (let i = 0; i < len; i++) {
                for (let j = i + 1; j < len; j++) {
                    if (arr[i] === arr[j]) {
                            arr.splice(j, 1);
                            // 每删除一个树，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能
                            len--;
                        j--;
                    }
                }
            }
            return arr;
        }
        ```
    + 方法三：利用indexOf
        ```js
        const unique2 = arr => {
            const res = [];
                for (let i = 0; i < arr.length; i++) {
                    if (res.indexOf(arr[i]) === -1) res.push(arr[i]);
                }
            return res;
        }
        ```
        当然也可以用include、filter，思路大同小异。
        <br/>


    + 方法四：利用include
        ```js
        const unique3 = arr => {
            const res = [];
            for (let i = 0; i < arr.length; i++) {
                if (!res.includes(arr[i])) res.push(arr[i]);
            }
            return res;
        }
        ```
    + 方法五：利用filter
        ```js
        const unique4 = arr => {
            return arr.filter((item, index) => {
                return arr.indexOf(item) === index;
            });
        }
        ```
    + 方法六：利用Map
        ```js 
        const unique5 = arr => {
            const map = new Map();
            const res = [];
            for (let i = 0; i < arr.length; i++) {
                if (!map.has(arr[i])) {
                    map.set(arr[i], true)
                    res.push(arr[i]);
                }
            }
            return res;
        }
        ```
- 3.类数组转化为数组
    类数组是具有length属性，但不具有数组原型上的方法。常见的类数组有arguments、DOM操作方法返回的结果。
    + 方法一：Array.from
        ```js
        Array.from(document.querySelectorAll('div'))
        ```
    + 方法二：Array.prototype.slice.call()
        ```js
        Array.prototype.slice.call(document.querySelectorAll('div'))
        ```
    + 方法三：扩展运算符
        ```js 
        [...document.querySelectorAll('div')]
        ```
    + 方法四：利用concat
        ```js
        Array.prototype.concat.apply([], document.querySelectorAll('div'));
        ```
- 4.生成类似[1-100]的数组：
    测试大量数据的数组时可以使用
    ```js
    // fill
    const arr = new Array(100).fill(0).map((item, index) => index + 1)

    // Array.from() 评论区大佬指出
    const arr = Array.from(Array(100), (v, k) => k + 1)

    // ... + array.keys() 评论区大佬指出 生成的是0-99的数组
    const ary = [...Array(100).keys()] 
    ```
    ==<font color="red">new Array(100)</font>== 会生成一个有100空位的数组，这个数组是不能被 ==<font color="red">map()，forEach(), filter(), reduce(), every() ，some()</font>== 遍历的，因为空位会被跳过（ ==<font color="red">for of</font>== 不会跳过空位，可以遍历）。 ==<font color="red">[...new Array(4)]</font>== 可以给空位设置默认值 ==<font color="red">undefined</font>==，从而使数组可以被以上方法遍历。
     <br/>

- 5.数组解构赋值应用
    ```js
    // 交换变量
    [a, b] = [b, a]
    [o.a, o.b] = [o.b, o.a]
    // 生成剩余数组
    const [a, ...rest] = [...'asdf'] // a：'a'，rest: ["s", "d", "f"]
    ```

- 6.数组浅拷贝
    ```js
    const arr = [1, 2, 3]
    const arrClone = [...arr]
    // 对象也可以这样浅拷贝
    const obj = { a: 1 }
    const objClone = { ...obj }
    ```
    浅拷贝方法有很多如 ==<font color="red">arr.slice(0, arr.length)/Arror.from(arr)</font>== 等，但是用了 ==<font color="red">...</font>== 操作符之后就不会再想用其他的了~
     <br/>

- 7.数组合并
    ```js
    const arr1 = [1, 2, 3]
    const arr2 = [4, 5, 6]
    const arr3 = [7, 8, 9]
    const arr = [...arr1, ...arr2, ...arr3]
    ```
     ==<font color="red">arr1.concat(arr2, arr3)</font>== 同样可以实现合并，但是用了 ==<font color="red">...</font>== 操作符之后就不会再想用其他的了~
      <br/>

- 8.数组取交集
    ```js
    const a = [0, 1, 2, 3, 4, 5]
    const b = [3, 4, 5, 6, 7, 8]
    const duplicatedValues = [...new Set(a)].filter(item => b.includes(item))
    duplicatedValues // [3, 4, 5]
    ```

- 9.数组取差集
    ```js
    const a = [0, 1, 2, 3, 4, 5]
    const b = [3, 4, 5, 6, 7, 8]
    const diffValues = [...new Set([...a, ...b])].filter(item => !b.includes(item) || !a.includes(item)) // [0, 1, 2, 6, 7, 8]
    ```

- 10.数组转对象
    ```js
    const arr = [1, 2, 3, 4]
    const newObj = {...arr} // {0: 1, 1: 2, 2: 3, 3: 4}
    const obj = {0: 0, 1: 1, 2: 2, length: 3}
    // 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上
    let newArr = [...obj] // Uncaught TypeError: object is not iterable...
    // 可以使用Array.form()将类数组对象转为数组
    let newArr = Array.from(obj) // [0, 1, 2]
    ```

- 11.数组摊平
    ```js
    const obj = {a: '群主', b: '男群友', c: '女裙友', d: '未知性别'}
    const getName = function (item) { return item.includes('群')}
    // 方法1
    const flatArr = Object.values(obj).flat().filter(item => getName(item))
    // 经大佬指点，更加简化（发现自己的抽象能力真的差~）
    const flatArr = Object.values(obj).flat().filter(getName)
    ```

- 12.数组常用遍历
    数组常用遍历有 ==forEach、every、some、filter、map、reduce、reduceRight、find、findIndex== 等方法
    + 遍历的混合使用
        ==filter、map==方法返回值仍旧是一个数组，所以可以搭配其他数组遍历方法混合使用。遍历越多效率越低
        ```js
        const arr = [1, 2, 3, 4, 5]
        const value = arr
            .map(item => item * 3)
            .filter(item => item % 2 === 0)
            .map(item => item + 1)
            .reduce((prev, curr) => prev + curr, 0)
        ```

    + 检测数组所有元素是否都符合判断条件
        ```js
        const arr = [1, 2, 3, 4, 5]
        const hasNum = arr.some(item => typeof item === 'number')
        ```

    + 检测数组是否有元素符合判断条件
        ```js
        const arr = [1, 2, 3, 4, 5]
        const hasNum = arr.some(item => typeof item === 'number')
        ```

    + 找到第一个符合条件的元素/下标
        ```js
        const arr = [1, 2, 3, 4, 5]
        const findItem = arr.find(item => item === 3) // 返回子项
        const findIndex = arr.findIndex(item => item === 3) // 返回子项的下标

        // 我以后再也不想看见下面这样的代码了😂
        let findIndex
        arr.find((item, index) => {
            if (item === 3) {
                findIndex = index
            }
        })   
        ```

- 13.数组使用误区
    + array.includes() 和 array.indexOf()
        ==array.includes()== 返回布尔值，==array.indexOf()== 返回数组子项的索引。==indexOf== 一定要在需要索引值的情况下使用。
        ```js
        const arr = [1, 2, 3, 4, 5]

        // 使用indexOf，需要用到索引值
        const index = arr.indexOf(1) // 0
        if (~index) { // 若index === -1，~index得到0，判断不成立；若index不为-1，则~index得到非0，判断成立。
            arr.spilce(index, 1)
        }

        // 使用includes，不需要用到索引值
        // 此时若用indexOf会造成上下文上的阅读负担：到底其他地方有没有用到这个index?
        const isExist = arr.includes(6) // true
        if (!isExist) {
            arr.push(6)
        }

        ```
        另外指出，==array.indexOf()== 找 ==NaN== 会找不到，返回 ==-1== ，==array.includes()== 能找到，返回 ==true== ~
        ```js
        [NaN].includes(NaN) // true
        [NaN].indexOf(NaN) // -1
        ```
    + array.find() 、 array.findIndex() 和 array.some()
        ==array.find()== 返回值是第一个符合条件的数组子项，==array.findIndex()== 返回第一个符合条件的数组子项的下标，==array.some()== 返回有无复合条件的子项，如有返回 ==true== ，若无返回 ==false== 。注意这三个都是短路操作，即找到符合条件的之后就不在继续遍历。
        <br/>
        在需要数组的子项的时候使用 ==array.find()== ；需要子项的索引值的时候使用 ==array.findIndex()== ；而若只需要知道有无符合条件的子项，则用 ==array.some()==。
        ```js
        const arr = [{label: '男', value: 0}, {label: '女', value: 1}, {label: '不男不女', value: 2}]

        // 使用some
        const isExist = arr.some(item => item.value === 2)
        if (isExist) {
            console.log('哈哈哈找到了')
        }

        // 使用find
        const item = arr.find(item => item.value === 2)
        if (item) {
            console.log(item.label)
        }

        // 使用findIndex
        const index = arr.findIndex(item => item.value === 2)
        if (~index) {
            const delItem = arr[index]
            arr.splice(index, 1)
            console.log(`你删除了${delItem.label}`)
        }
        ```
        建议在只需要布尔值的时候和数组子项是字符串或数字的时候使用 ==array.some()==：
        ```js
            // 当子包含数字0的时候可能出错
            const arr = [0, 1, 2, 3, 4]

            // 正确
            const isExist = arr.some(item => item === 0)
            if (isExist) {
                console.log('存在要找的子项，很舒服~')
            }

            // 错误
            const isExist = arr.find(item => item === 0)
            if (isExist) { // isExist此时是0，隐式转换为布尔值后是false
                console.log('执行不到这里~')
            }

            // 当子项包含空字符串的时候也可能出错
            const arr = ['', 'asdf', 'qwer', '...']

            // 正确
            const isExist = arr.some(item => item === '')
            if (isExist) {
                console.log('存在要找的子项，很舒服~')
            }

            // 错误
            const isExist = arr.find(item => item === '')
            if (isExist) { // isExist此时是''，隐式转换为布尔值后是false
                console.log('执行不到这里~')
            }
        ```

    + array.find() 和 array.filter()
        只需要知道 ==array.filter()== 返回的是所有符合条件的子项组成的数组，会遍历所有数组；而 ==array.find()== 只返回第一个符合条件的子项，是短路操作。
        <br/>
        **合理使用 Set 数据结构**
        <br/>
        由于 es6 原生提供了 ==Set== 数据结构，而 ==Set== 可以保证子项不重复，且和数组转换十分方便，所以在一些可能会涉及重复添加的场景下可以直接使用 ==Set== 代替 ==Array==，避免了多个地方重复判断是否已经存在该子项。
        ```js
        const set = new Set()
        set.add(1)
        set.add(1)
        set.add(1)
        set.size // 1
        const arr = [...set] // arr: [1]
        ```
        **强大的reduce（奇巧淫技）**
        ![reduce](./image/reduce.png "reduce")

        ==array.reduce== 遍历并将当前次回调函数的返回值作为下一次回调函数执行的第一个参数。

        利用 ==array.reduce== 替代一些需要多次遍历的场景，可以极大提高代码运行效率。

        * 1.利用 ==reduce== 输出一个数字/字符串
            假如有如下每个元素都由字母's'加数字组成的数组arr，现在找出其中最大的数字：（arr不为空）
            ```js
            const arr = ['s0', 's4', 's1', 's2', 's8', 's3']

            // 方法1  进行了多次遍历，低效
            const newArr = arr.map(item => item.substring(1)).map(item => Number(item))
            const maxS = Math.max(...newArr)

            // 方法2  一次遍历
            const maxS = arr.reduce((prev, cur) => {
            const curIndex = Number(cur.replace('s', ''))
            return curIndex > prev ? curIndex : prev
            }, 0)

            ```
        * 2.利用 ==reduce== 输出一个数组/对象
            ```js
            const arr = [1, 2, 3, 4, 5]

            // 方法1  遍历了两次，效率低
            const value = arr.filter(item => item % 2 === 0).map(item => ({ value: item }))

            // 方法1  一次遍历，效率高
            const value = arr.reduce((prev, curr) => {
                return curr % 2 === 0 ? [...prev, { value: curr }] : prev
            }, [])

            ```
            掌握了上面两种用法，结合实际需要，就可以用 reduce/reduceRight 实现各种奇巧淫技了。
        
        实例：利用 reduce 做下面这样的处理来生成想要的 html 字符串：
        ```js
        // 后端返回数据
        const data = {
        'if _ then s9': [
            '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生',
            '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生',
            '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'
            ],
        'if C then s4': [
            '当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性',
            '当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性'
        ]
        }

        const ifthens = Object.entries(data).reduce((prev, cur) => {
        const values = cur[1].reduce((prev, cur) => `${prev}<p>${cur}</p>`, '')
        return `
            ${prev}
            <li>
            <p>${cur[0]}</p>
            ${values}
            </li>
        `
        }, '')

        const html = `
        <ul class="nlp-notify-body">
            ${ifthens}
        </ul>
        `
        ```
        生成的 html 结构如下：
        ```html
        <ul class="nlp-notify-body">            
        <li>
            <p>if _ then s9</p>
            <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>
            <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>
            <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>
        </li>
        <li>
            <p>if C then s4</p>
            <p>当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性</p>
            <p>当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性</p>
        </li>
        </ul>
        ```
        这里还有一个替代 reverse 函数的技巧
        由于 ==array.reverse()== 函数会改变原数组自身，这样就限制了一些使用场景。如果我想要一个不会改变数组自身的 ==reverse== 函数呢？拿走！
        ```js
        const myReverse = (arr = []) => {
            return  arr.reduceRight((prev, cur) => [...prev, cur], []) // 也可以返回逗号表达式 (prev.push(cur), prev)
        }
        ```
        ==reduce== 太强大了，这里只能展示基本用法。到底有多强大推荐查看大佬这篇[《25个你不得不知道的数组reduce高级用法》](https://juejin.im/post/6844904063729926152)




#### 7.new的原理
- 生成一个新的对象
- 链接到原型上
- 绑定this
- 返回一个新的对象
```js
// 实现 new 
function create(Con, ...args){
  let obj = {} //生成新对象
  obj.__proto__ = Con.prototype //链接原型
  let res = Con.apply(obj,args)
  return res instanceof Object ? res : obj //确保返回的是对象
}

```

#### 8.闭包
> 闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

```js
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}

```
##### 面试题

```js
for ( var i=1; i<=5; i++) {
    setTimeout( function timer() { // setTimeout是异步 进入队列等待同步任务执行结束
        console.log( i );
    }, i*1000 );
}

```
```js
// 第一种解决方法  闭包
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
// 第二种解决方法 let 形成块级作用域
for ( let i=1; i<=5; i++) {
    setTimeout( function timer() { 
        console.log( i );
    }, i*1000 );
} 
// 相当于 
{ // 形成块级作用域
  let i = 0
  {
    let is = i
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
  }
  i++
  {
    let ii = i
  }
  i++
  {
    let ii = i
  }
  ...
}


```
#### 流程图（只是写着玩）
```flow
st=>start: 开始
op=>operation: 喜欢我吗
cond=>condition: yes or no?
e=>end: 我没有逼着你喜欢我哦
st->op->cond
cond(yes)->e
cond(no)->op
```

#### 大招（当我在放屁，毕竟鸡汤必不可少）
- [ ] 1.姿态不能太低
- [ ] 2.吸引而不是感动 
- [ ] 3.不能急于求成
- [ ] 4.养成铁打不变的习惯最重要，提升自己最重要
- [ ] 5.关系处于什么阶段做什么事，不能越级
- [ ] 6.遇挫放空自己，冥想/出去玩玩
- [ ] 7.一个人喜不喜欢自己，除了她自己外，最清楚的莫过于自己，不要自欺欺人
- [ ] 8.一场火车旅行




#### 反击日记
> 昨天发了15000的工资，你以为我会因为厂里包吃包住就把工资全部都给你吗？不，我只给你300，因为我同时舔了50个
    >> 下雨了，你果然没带伞，叫我给你和你男朋友带把大伞过来，我呸，真当我是工具人，我带了一把小伞，淋死他<br/>
    >>> 每天我都会对你说要是晚上想我就给我打电话，我睡着了也接，但你一次也没有打过，但凡你要是打过一次，只一次，你就会知道，我睡之前其实会关机的
    >>>> baby，咱俩处对象吧，每天跟你分享新鲜事，消息秒回，电话秒接，工资都给你，经常给你准备小惊喜，只对你一个人好。你觉得你配吗在这看半天？
    >>>>> 你以为我是备胎，你错了，只要我舔的女神够多，你就是我的备胎
    >>>>>> 我还是很喜欢你，就像，我如果有一百块钱，我愿意花30打车去找你，然后花60去找狗胖子买两张惊奇队长，然后花八块钱给你买一杯冰阔乐。看完电影，我会用最后两块钱，去坐公交，去银行取两万自己去吃螃蟹龙虾三文鱼蛋糕松塔章鱼丸子酸菜鱼香辣鸡翅麦旋风芒果布丁金丝面羊肉串火锅
    >>>>>>> 你不知道我在洗澡时因为你发来的信息擦干手秒回的样子，你不知道我在很困的时候依然硬撑着和你说等你睡了我再睡的样子，你不知道我每天没事就抱着手机等你回消息的样子，你全都没见过，因为我没有做过



***
# 面试题
## （字节跳动）

> 1px的问题可以如何去解决

出现1px的原因是设计图上的1px指的是设备像素，而不是css像素。DPR这个视网膜屏幕的概念最先是由苹0果公司提出，计算公式：DPR = CSS像素/设备像素
以Iphone6为例，DPR = 750/375=2，在DPR为2的屏幕下，1px的物理像素会以2px渲染出来，解决方法有：
* 我们可以用0.5px的css像素
* 修改viewport
* 伪类＋scale，先给伪类设200%的宽度，然后再transform：scaleY(0.5)

> Less和css的区别，Less函数有了解过吗

less是css预处理器，可以让我们写出易于维护的css代码，less可以申明全局变量， [less官网](http://lesscss.cn/functions)

> 在浏览器中输入一个URL的整体过程是怎么样的

1、当我们在浏览器地址栏按下键盘的时候，浏览器就会启动一个算法去书签栏和历史记录中按照我们输入的字母进行筛选、展示一个我们可能会访问的URL
2、当我们选定了URL按下回车时，浏览器就会开始构建请求行，然后检测这个域名是否合法，如果合法就将此任务给网络请求线程
3、构建好请求行后就会去检测强缓存是否有效（这个步骤不会发送网络请求），如果无效，就会开始调用DNS协议进行域名解析，如果之前访问过这个URL，那么浏览器就会吧DNS解析后的IP地址保存下来，下次访问就直接命中（大概可以节约50~200ms),如果没有就需要去网络运营商或者DNS服务器上寻找
4、拿到DNS解析的IP地址后，就会构建HTTP请求，开始TCP三次握手建立稳定链接，客户端向服务器发送一个SYN（同步序列码），服务端收到后返回一个新的SYN + ACK（在第一个SYN上做计算后生成的回复消息），客户端收到后回复一个ACK，三次握手建立完毕。
5、建立好三次握手后，TCP协议为了传输方便，会将HTTP报文切割并编码成一个个数据包，随后转交给网络层。
6、网络层拿到这些数据包后，通过IP地址，配合ARP协议反查出MAC地址，开始传输数据，服务器收到这些数据后，将在TCP传输层协议中被分割的报文还原成完整的，这个时候一般会校验是否有权限，是否设置了缓存以及是否过期等。如果设置了协商缓存，那么会返回304状态码通知浏览器使用协商缓存，否则开始响应。响应完毕后，服务器会判断Connection字段是否为keep-alive（在HTTP1.1中是默认值），不是则断开。
7、接下来就是浏览器开始解析请求到的文件，首先调用GUI线程并进行解析HTML和CSS文件，对HTML文件使用标记化和建树算法，根据文件中设置的<!DOCTYPE>标准来生成DOM树，对CSS文件进行格式化和标准化生成的CSSOM树，最后合并成合成树。注意HTML和CSS文件解析是互不影响的，但是会影响最后的合成树生成的速度，所以CSS文件中不要放@import，它总是在CSS文件解析完毕后再去加载相应的资源。
8、另外GUI线程和JS线程是互斥的，当解析到HTML文件中的script标签时，就会挂起GUI线程，从而阻塞渲染，所以script标签中不要写async，他总是异步加载，然后立即执行，但你可以写defer拿到合成树后，为了提高渲染效率，因为复杂的图层总是会由GUP单独绘制（GPU加速），不会影响其他的图层，所以开始创建图层树。普通文档流可以算是复杂图层，除此之外absolute、transform、opacity、canvas等元素都能形成复杂图层，所以说动画最好放在absolute等元素上、用transform代替left/top
9、浏览器将这些图层的绘制生成一个个绘制指令，然后交给合成池去进行绘制，生成图块和位图，最后显示出当前的页面。

> 描述下浏览器页面渲染的过程

同上一题

> 浏览器白屏是什么导致的




